

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>python-hawkey Tutorial &mdash; Hawkey 0.2.12-1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2.12-1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Hawkey 0.2.12-1 documentation" href="index.html" />
    <link rel="next" title="python-hawkey Reference Manual" href="reference-py.html" />
    <link rel="prev" title="FAQ" href="faq.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="reference-py.html" title="python-hawkey Reference Manual"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="FAQ"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Hawkey 0.2.12-1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="python-hawkey-tutorial">
<h1><a class="toc-backref" href="#id1">python-hawkey Tutorial</a><a class="headerlink" href="#python-hawkey-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#python-hawkey-tutorial" id="id1">python-hawkey Tutorial</a><ul>
<li><a class="reference internal" href="#setup" id="id2">Setup</a></li>
<li><a class="reference internal" href="#the-sack-object" id="id3">The Sack Object</a></li>
<li><a class="reference internal" href="#loading-rpmdb" id="id4">Loading RPMDB</a></li>
<li><a class="reference internal" href="#loading-yum-repositories" id="id5">Loading Yum Repositories</a></li>
<li><a class="reference internal" href="#case-for-loading-the-filelists" id="id6">Case for Loading the Filelists</a></li>
<li><a class="reference internal" href="#building-and-reusing-the-repo-cache" id="id7">Building and Reusing the Repo Cache</a></li>
<li><a class="reference internal" href="#queries" id="id8">Queries</a></li>
<li><a class="reference internal" href="#resolving-things-with-goals" id="id9">Resolving things with Goals</a><ul>
<li><a class="reference internal" href="#query-installs" id="id10">Query Installs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="setup">
<h2><a class="toc-backref" href="#id2">Setup</a><a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h2>
<p>First of, make sure hawkey is installed on your system, this should work from your terminal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hawkey</span>
</pre></div>
</div>
</div>
<div class="section" id="the-sack-object">
<h2><a class="toc-backref" href="#id3">The Sack Object</a><a class="headerlink" href="#the-sack-object" title="Permalink to this headline">¶</a></h2>
<p><em>Sack</em> is an abstraction for a collection of packages. Sacks in hawkey are
toplevel objects carrying much of hawkey&#8217;s of functionality. You&#8217;ll want to
create one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sack</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Sack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Initially, the sack contains no packages.</p>
</div>
<div class="section" id="loading-rpmdb">
<h2><a class="toc-backref" href="#id4">Loading RPMDB</a><a class="headerlink" href="#loading-rpmdb" title="Permalink to this headline">¶</a></h2>
<p>hawkey is a lib for listing, querying and resolving dependencies of <em>packages</em>
from <em>repositories</em>. On most linux distributions you always have at least <em>the
system repo</em> (in Fedora it is the RPM database). To load it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sack</span><span class="o">.</span><span class="n">load_system_repo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="go">1683</span>
</pre></div>
</div>
<p>Hawkey always knows the name of every repository. Repositories loaded from Yum
are named by the user, the system repostiroy is always called <tt class="docutils literal"><span class="pre">&#64;System</span></tt>.</p>
</div>
<div class="section" id="loading-yum-repositories">
<h2><a class="toc-backref" href="#id5">Loading Yum Repositories</a><a class="headerlink" href="#loading-yum-repositories" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s be honest here: all the fun in packaging comes from packages you haven&#8217;t
installed yet. Information about them, their <em>metadata</em>, can be obtained from
different sources and typically they are downloaded from an HTTP mirror (another
possibilities are FTP server, NFS mount, DVD distribution media, etc.). Hawkey
does not provide any means to discover and obtain the metadata locally: it is up
to the client to provide valid readable paths to the Yum metadata XML
files. Structures used for passing the information to hawkey are the hawkey
<tt class="xref py py-class docutils literal"><span class="pre">Repos</span></tt>. Suppose we somehow obtained the metadata and placed it in
<tt class="docutils literal"><span class="pre">/home/akozumpl/tmp/repodata</span></tt>. We can then load the metadata into hawkey:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="s">&quot;/home/akozumpl/tmp/repodata/</span><span class="si">%s</span><span class="s">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Repo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;experimental&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span><span class="o">.</span><span class="n">repomd_fn</span> <span class="o">=</span> <span class="n">path</span> <span class="o">%</span> <span class="s">&quot;repomd.xml&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span><span class="o">.</span><span class="n">primary_fn</span> <span class="o">=</span> <span class="n">path</span> <span class="o">%</span> <span class="s">&quot;f7753a2636cc89d70e8aaa1f3c08413ab78462ca9f48fd55daf6dedf9ab0d5db-primary.xml.gz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repo</span><span class="o">.</span><span class="n">filelists_fn</span> <span class="o">=</span> <span class="n">path</span> <span class="o">%</span> <span class="s">&quot;0261e25e8411f4f5e930a70fa249b8afd5e86bb9087d7739b55be64b76d8a7f6-filelists.xml.gz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sack</span><span class="o">.</span><span class="n">load_yum_repo</span><span class="p">(</span><span class="n">repo</span><span class="p">,</span> <span class="n">load_filelists</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="go">1685</span>
</pre></div>
</div>
<p>The number of packages in the Sack will increase by the number of packages found
in the repository (two in this case, it is an experimental repo after all).</p>
</div>
<div class="section" id="case-for-loading-the-filelists">
<h2><a class="toc-backref" href="#id6">Case for Loading the Filelists</a><a class="headerlink" href="#case-for-loading-the-filelists" title="Permalink to this headline">¶</a></h2>
<p>What the <tt class="docutils literal"><span class="pre">load_filelists=True</span></tt> argument to <tt class="docutils literal"><span class="pre">load_yum_repo()</span></tt> above does is
instruct hawkey to process the <tt class="docutils literal"><span class="pre">&lt;hash&gt;filelists.xml.gz</span></tt> file we passed in and
which contains structured list of absolute paths to all files of all packages
within the repo. This information can be used for two purposes:</p>
<ul class="simple">
<li>Finding a package providing given file. For instance, you need the file
<tt class="docutils literal"><span class="pre">/usr/share/man/man3/fprintf.3.gz</span></tt> which is not installed. Consulting
filelists (directly or through hawkey) can reveal the file is in the
<tt class="docutils literal"><span class="pre">man-pages</span></tt> package.</li>
<li>Depsolving. Some packages require concrete files as their dependencies. To
know if these are resolvable and how, the solver needs to know what package
provides what files.</li>
</ul>
<p>Some files provided by a package (e.g those in <tt class="docutils literal"><span class="pre">/usr/bin</span></tt>) are always visible
even without loading the filelists. Well-behaved packages requiring only those
can be thus resolved directly. Unortunately, there are packages that don&#8217;t
behave and it is hard to tell in advance when you&#8217;ll deal with one.</p>
<p>The strategy for using <tt class="docutils literal"><span class="pre">load_filelists=True</span></tt> is thus:</p>
<ul class="simple">
<li>Use it if you know you&#8217;ll do resolving (i.e. you&#8217;ll use <tt class="xref py py-class docutils literal"><span class="pre">Goal</span></tt>).</li>
<li>Use it if you know you&#8217;ll be trying to match files to their packages.</li>
<li>Use it if you are not sure.</li>
</ul>
</div>
<div class="section" id="building-and-reusing-the-repo-cache">
<h2><a class="toc-backref" href="#id7">Building and Reusing the Repo Cache</a><a class="headerlink" href="#building-and-reusing-the-repo-cache" title="Permalink to this headline">¶</a></h2>
<p>Internally to hold the package information and perform canonical resolving
hawkey uses <a class="reference external" href="https://github.com/openSUSE/libsolv">Libsolv</a>. One great benefit this library offers is providing
writing and reading of metadata cache files in libsolv&#8217;s own binary format
(files with <tt class="docutils literal"><span class="pre">.solv</span></tt> extension, typically). At a cost of few hundreds of
milliseconds, using the solv files reduces repo load times from seconds to tens
of milliseconds. It is thus a good idea to write and use the solv files every
time you plan to use the same repo for more than one Sack (which is at least
every time your hawkey program is run). To do that use <tt class="docutils literal"><span class="pre">build_cache=True</span></tt> with
<tt class="xref py py-func docutils literal"><span class="pre">load_yum_repo()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">load_system_repo()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sack</span><span class="o">.</span><span class="n">load_system_repo</span><span class="p">(</span><span class="n">build_cache</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, Hawkey creates <tt class="docutils literal"><span class="pre">&#64;System.cache</span></tt> under the
<tt class="docutils literal"><span class="pre">/var/tmp/hawkey-&lt;your_login&gt;-&lt;random_hash&gt;</span></tt> directory. This is the hawkey
cache directory, which you can always delete later (deleting the cache files in
the process). The <tt class="docutils literal"><span class="pre">.solv</span></tt> files are picked up automatically the next time you
try to create a hawkey sack. Except for a much higher speed of the operation
this will be completely transparent to you:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Sack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">load_system_repo</span><span class="p">()</span>
</pre></div>
</div>
<p>By the way, the cache directory also contains a logfile with some boring
debugging information.</p>
</div>
<div class="section" id="queries">
<h2><a class="toc-backref" href="#id8">Queries</a><a class="headerlink" href="#queries" title="Permalink to this headline">¶</a></h2>
<p>Query is the means in hawkey of finding a package based on one or more criteria
(name, version, repository of origin). Its interface is loosely based on
<a class="reference external" href="https://docs.djangoproject.com/en/1.4/topics/db/queries/">Django&#8217;s QuerySets</a>, the main concepts being:</p>
<ul class="simple">
<li>a fresh Query object matches all packages in the Sack and the selection is
gradually narrowed down by calls to <tt class="xref py py-meth docutils literal"><span class="pre">Query.filter()</span></tt></li>
<li>applying a <tt class="xref py py-meth docutils literal"><span class="pre">Query.filter()</span></tt> does not start to evaluate the Query, i.e. the
Query is lazy. Query is only evaluated when we explicitly tell it to or when
we start to iterate it.</li>
<li>use Python keyword arguments to <tt class="xref py py-meth docutils literal"><span class="pre">Query.filter()</span></tt> to specify the filtering
criteria.</li>
</ul>
<p>For instance, let&#8217;s say I want to find all installed packages which name ends
with <tt class="docutils literal"><span class="pre">gtk</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">repo</span><span class="o">=</span><span class="n">hawkey</span><span class="o">.</span><span class="n">SYSTEM_REPO_NAME</span><span class="p">,</span> <span class="n">name__glob</span><span class="o">=</span><span class="s">&#39;*gtk&#39;</span><span class="p">)</span>
<span class="go">&lt;hawkey.Query object at 0x7fa477e73320&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pkg</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">pkg</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">NetworkManager-gtk-1:0.9.4.0-9.git20120521.fc17.x86_64</span>
<span class="go">authconfig-gtk-6.2.1-1.fc17.x86_64</span>
<span class="go">clutter-gtk-1.2.0-1.fc17.x86_64</span>
<span class="go">libchamplain-gtk-0.12.2-1.fc17.x86_64</span>
<span class="go">libreport-gtk-2.0.10-3.fc17.x86_64</span>
<span class="go">pinentry-gtk-0.8.1-6.fc17.x86_64</span>
<span class="go">python-slip-gtk-0.2.20-2.fc17.noarch</span>
<span class="go">transmission-gtk-2.50-2.fc17.x86_64</span>
<span class="go">usermode-gtk-1.109-1.fc17.x86_64</span>
<span class="go">webkitgtk-1.8.1-2.fc17.x86_64</span>
<span class="go">xdg-user-dirs-gtk-0.9-1.fc17.x86_64</span>
</pre></div>
</div>
<p>Or I want to find the latest version of all <tt class="docutils literal"><span class="pre">python</span></tt> packages the Sack knows of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;python&#39;</span><span class="p">,</span> <span class="n">latest</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&lt;hawkey.Query object at 0x7fa477e73460&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">pkg</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">pkg</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">python-2.7.3-6.fc17.x86_64</span>
</pre></div>
</div>
<p>You can also test a <tt class="xref py py-class docutils literal"><span class="pre">Query</span></tt> for its truth value. It will be true whenever
the query matched at least one package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="s">&#39;/boot/vmlinuz-3.3.4-5.fc17.x86_64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">q</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;match&#39;</span>
<span class="gp">...</span>
<span class="go">match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="s">&#39;/booty/vmlinuz-3.3.4-5.fc17.x86_64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">q</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;match&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s">&#39;no match&#39;</span>
<span class="gp">...</span>
<span class="go">no match</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the Query hasn&#8217;t been evaluated already then it is evaluated whenever it&#8217;s
length is taken (either via <tt class="docutils literal"><span class="pre">len(q)</span></tt> or <tt class="docutils literal"><span class="pre">q.count()</span></tt>), when it is tested for
truth and when it is explicitly evaluated with <tt class="docutils literal"><span class="pre">q.run()</span></tt>.</p>
</div>
</div>
<div class="section" id="resolving-things-with-goals">
<h2><a class="toc-backref" href="#id9">Resolving things with Goals</a><a class="headerlink" href="#resolving-things-with-goals" title="Permalink to this headline">¶</a></h2>
<p>Many <tt class="xref py py-class docutils literal"><span class="pre">Sack</span></tt> sessions culminate in bout of dependency resolving, that is
answering a question along the lines of &#8220;I have a package X in a repository
here, what other packages do I need to install/update to have X installed and
all its dependencies recursively satisfied?&#8221; Suppose we want to install <a class="reference external" href="http://springrts.com/">the RTS
game Spring</a>. First let&#8217;s locate the latest version of
the package in repositories:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;spring&#39;</span><span class="p">,</span> <span class="n">latest</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pkg</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;spring&#39;</span><span class="p">,</span> <span class="n">latest</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">pkg</span><span class="p">)</span>
<span class="go">&#39;spring-88.0-2.fc17.x86_64&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pkg</span><span class="o">.</span><span class="n">reponame</span>
<span class="go">&#39;fedora&#39;</span>
</pre></div>
</div>
<p>Then build the <tt class="xref py py-class docutils literal"><span class="pre">Goal</span></tt> object and tell it our goal is installing the
<tt class="docutils literal"><span class="pre">pkg</span></tt>. Then we fire off the libsolv&#8217;s dependency resolver by running the
goal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Goal</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">pkg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">True</span></tt> as a return value here indicates that libsolv could find a solution to
our goal. This is not always the case, there are plenty of situations when there
is no solution, the most common one being a package should be installed but one
of its dependnecies is missing from the sack.</p>
<p>The three methods <tt class="xref py py-meth docutils literal"><span class="pre">Goal.list_installs()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">Goal.list_upgrades()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">Goal.list_erasures()</span></tt> can show which packages should be
installed/upgraded/erased to satisfy the packaging goal we set out to achieve
(the mapping of <tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt> over the results below ensures human readable
package names instead of numbers are presented):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">list_installs</span><span class="p">())</span>
<span class="go">[&#39;spring-88.0-2.fc17.x86_64&#39;, &#39;spring-installer-20090316-10.fc17.x86_64&#39;, &#39;springlobby-0.139-3.fc17.x86_64&#39;, &#39;spring-maps-default-0.1-8.fc17.noarch&#39;, &#39;wxBase-2.8.12-4.fc17.x86_64&#39;, &#39;wxGTK-2.8.12-4.fc17.x86_64&#39;, &#39;rb_libtorrent-0.15.9-1.fc17.x86_64&#39;, &#39;GeoIP-1.4.8-2.1.fc17.x86_64&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">list_upgrades</span><span class="p">())</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">list_erasures</span><span class="p">())</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>So what does it tell us? That given the state of the given system and the given
repository we used, 8 packages need to be installed,
<tt class="docutils literal"><span class="pre">spring-88.0-2.fc17.x86_64</span></tt> itself included. No packages need to be upgraded
or erased.</p>
<div class="section" id="query-installs">
<h3><a class="toc-backref" href="#id10">Query Installs</a><a class="headerlink" href="#query-installs" title="Permalink to this headline">¶</a></h3>
<p>For certain very simple queries we can do installs directly without ever executing them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Goal</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;spring&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">list_installs</span><span class="p">())</span>
<span class="go">[&#39;spring-88.0-2.fc17.x86_64&#39;, &#39;spring-installer-20090316-10.fc17.x86_64&#39;, &#39;springlobby-0.139-3.fc17.x86_64&#39;, &#39;spring-maps-default-0.1-8.fc17.noarch&#39;, &#39;wxBase-2.8.12-4.fc17.x86_64&#39;, &#39;wxGTK-2.8.12-4.fc17.x86_64&#39;, &#39;rb_libtorrent-0.15.9-1.fc17.x86_64&#39;, &#39;GeoIP-1.4.8-2.1.fc17.x86_64&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">list_upgrades</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">list_erasures</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Notice we arrived at the same result as before, when the query got iterated
first. When a <tt class="xref py py-class docutils literal"><span class="pre">Query</span></tt> is passed directly to <tt class="xref py py-meth docutils literal"><span class="pre">Goal.install()</span></tt> hawkey
examines the query and without running it instructs libsolv to find <em>the best
matching package</em> for it and add that for installation. It saves user some
deicsions like which version should be installed or what architecture (this gets
very relevant with multiarch libraries).</p>
<p>Think about the queries in this context more as <em>specifiers</em> and less as <em>chain
of filters</em>. Not all kinds of Query filters can used for Goal as when searching
for a package. In fact in this context, currently only <tt class="docutils literal"><span class="pre">name</span></tt> and <tt class="docutils literal"><span class="pre">arch</span></tt>
filters are recognized, the others raise an error:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">goal</span> <span class="o">=</span> <span class="n">hawkey</span><span class="o">.</span><span class="n">Goal</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">goal</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">hawkey</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">sack</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;spring&#39;</span><span class="p">,</span> <span class="n">repo</span><span class="o">=</span><span class="s">&#39;fedora&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">_hawkey.QueryException</span>: <span class="n">Query unsupported in this context.</span>
</pre></div>
</div>
<p>If you mean to install <em>all packages</em> matching an arbitrarily complex query,
just use the method describe above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">goal</span><span class="o">.</span><span class="n">install</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">python-hawkey Tutorial</a><ul>
<li><a class="reference internal" href="#setup">Setup</a></li>
<li><a class="reference internal" href="#the-sack-object">The Sack Object</a></li>
<li><a class="reference internal" href="#loading-rpmdb">Loading RPMDB</a></li>
<li><a class="reference internal" href="#loading-yum-repositories">Loading Yum Repositories</a></li>
<li><a class="reference internal" href="#case-for-loading-the-filelists">Case for Loading the Filelists</a></li>
<li><a class="reference internal" href="#building-and-reusing-the-repo-cache">Building and Reusing the Repo Cache</a></li>
<li><a class="reference internal" href="#queries">Queries</a></li>
<li><a class="reference internal" href="#resolving-things-with-goals">Resolving things with Goals</a><ul>
<li><a class="reference internal" href="#query-installs">Query Installs</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="faq.html"
                        title="previous chapter">FAQ</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="reference-py.html"
                        title="next chapter">python-hawkey Reference Manual</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial-py.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="reference-py.html" title="python-hawkey Reference Manual"
             >next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="FAQ"
             >previous</a> |</li>
        <li><a href="index.html">Hawkey 0.2.12-1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Red Hat.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>